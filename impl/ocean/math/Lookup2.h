/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef META_OCEAN_MATH_LOOKUP2_H
#define META_OCEAN_MATH_LOOKUP2_H

#include "ocean/math/Math.h"
#include "ocean/math/Interpolation.h"
#include "ocean/math/Vector2.h"

#include <vector>

namespace Ocean
{

/**
 * This class implements a 2D lookup object allowing to separate a two dimensional lookup area into individual bins.
 * The entire lookup area covers an integer two-dimensional space starting at the origin.<br>
 * Lookup values are generated by interpolating lookup values between neighboring bins.
 * @tparam T The data type of the stored lookup values
 * @tparam TScalar The data type of the scalar values, either 'float' or 'double'
 * @ingroup math
 */
template <typename T, typename TScalar = Scalar>
class Lookup2
{
	public:

		/**
		 * Definition of the lookup data type.
		 */
		typedef T Type;

	protected:

		/**
		 * Definition of a vector holding lookup values.
		 */
		typedef std::vector<T> Values;

	public:

		/**
		 * Returns a pointer to the constant bin data (row aligned).
		 * @return Bin data
		 */
		inline const T* data() const;

		/**
		 * Returns a pointer to the bin data (row aligned).
		 * @return Bin data
		 */
		inline T* data();

		/**
		 * Returns the horizontal dimension of this lookup object.
		 * @return Horizontal dimension
		 */
		inline size_t sizeX() const;

		/**
		 * Returns the vertical dimension of this lookup object.
		 * @return Vertical dimension
		 */
		inline size_t sizeY() const;

		/**
		 * Returns the number of horizontal bins of this lookup object.
		 * @return Number of horizontal bins
		 */
		inline size_t binsX() const;

		/**
		 * Returns the number of vertical bins of this lookup object.
		 * @return Number of vertical bins
		 */
		inline size_t binsY() const;

		/**
		 * Returns whether this lookup object does not hold any lookup bin.
		 * @return True, if so
		 */
		inline bool isEmpty() const;

		/**
		 * Returns whether this lookup object holds at least one lookup bin.
		 * @return True, if so
		 */
		explicit inline operator bool() const;

		/**
		 * Returns whether two lookup objects are identical.
		 * @param lookup Second lookup object
		 * @return True, if so
		 */
		bool operator==(const Lookup2<T, TScalar>& lookup) const;

		/**
		 * Returns whether two lookup objects are not identical.
		 * @param lookup Second lookup object
		 * @return True, if so
		 */
		inline bool operator!=(const Lookup2<T, TScalar>& lookup) const;

	protected:

		/**
		 * Creates a new empty lookup object.
		 */
		Lookup2() = default;

		/**
		 * Copy constructor.
		 * @param lookup The lookup object to be moved
		 */
		inline Lookup2(const Lookup2<T, TScalar>& lookup);

		/**
		 * Move constructor.
		 * @param lookup The lookup object to be moved
		 */
		inline Lookup2(Lookup2<T, TScalar>&& lookup) noexcept;

		/**
		 * Assign operator.
		 * @param lookup The lookup object that will be moved
		 * @return Reference to this object
		 */
		Lookup2<T, TScalar>& operator=(const Lookup2<T, TScalar>& lookup);

		/**
		 * Move operator.
		 * @param lookup The lookup object that will be moved
		 * @return Reference to this object
		 */
		Lookup2<T, TScalar>& operator=(Lookup2<T, TScalar>&& lookup) noexcept;

	protected:

		/// Horizontal dimension of this lookup object.
		size_t sizeX_ = 0;

		/// Vertical dimension of this lookup object.
		size_t sizeY_ = 0;

		/// Number of horizontal bins.
		size_t binsX_ = 0;

		/// Number of vertical bins.
		size_t binsY_ = 0;

		/// Inverse horizontal dimension of this lookup object.
		TScalar invSizeX_ = 0;

		/// Inverse vertical dimension of this lookup object.
		TScalar invSizeY_ = 0;

		/// Inverse number of horizontal bins.
		TScalar invBinsX_ = 0;

		/// Inverse number of vertical bins.
		TScalar invBinsY_ = 0;

		/// The values of the lookup bins.
		Values values_;
};

/**
 * This class implements a 2D lookup object with values at the bins' center positions defining the individual lookup values.
 * This area is separated into individual neighboring bins (with almost same size) each covering an integer-sized area.<br>
 * The sizes of the bins may vary due to rounding issues if the number of bins is not dividable without remainder in relation to the size of the lookup object.<br>
 * Each bin covers a whole-numbered number of elements (e.g., pixels) and the left, top, right and bottom position of each bin is also an integer number.<br>
 * However, the center position of the bins may have a non-integer position.
 *
 * The lookup table with 4x2 bins has the following layout:
 * <pre>
 *   ---   ---   ---   ---
 * |  +  |  +  |  +  |  +  |
 *   ---   ---   ---   ---
 * |  +  |  +  |  +  |  +  |
 *   ---   ---   ---   ---
 * </pre>
 * With '+' showing the center positions of the lookup values.<br>
 * Thus, the lookup table has 4 horizontal bins and 4 horizontal lookup values.<br>
 * All lookup values are located inside the specified size of the lookup object.<br>
 * The vertical positions are accordingly.
 * @tparam T The data type of the stored lookup values
 * @tparam TScalar The data type of the scalar values, either 'float' or 'double'
 * @see LookupCorner2
 * @ingroup math
 */
template <typename T, typename TScalar = Scalar>
class LookupCenter2 : public Lookup2<T, TScalar>
{
	public:

		/**
		 * Creates a new empty lookup object.
		 */
		LookupCenter2() = default;

		/**
		 * Copy constructor.
		 * @param lookup The lookup object to be copied
		 */
		inline LookupCenter2(const LookupCenter2<T, TScalar>& lookup);

		/**
		 * Move constructor.
		 * @param lookup The lookup object to be moved
		 */
		inline LookupCenter2(LookupCenter2<T, TScalar>&& lookup) noexcept;

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * Beware: The bin values will be initialized with the default constructor of the template class.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 */
		LookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY);

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 * @param binValues The bin values of the lookup object (row aligned), binsX * binsY values must be provided
		 */
		LookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binValues);

		/**
		 * Creates a new lookup object by definition of the dimensions and a given lookup object.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param lookup The lookup object specifying the lookup values and the number of lookup bins
		 */
		LookupCenter2(const size_t sizeX, const size_t sizeY, const LookupCenter2<T, TScalar>& lookup);

		/**
		 * Returns whether a given position lies inside this lookup object and therefore whether this position can be applied for the interpolation functions.
		 * @param x Precise horizontal position for the resulting lookup value, with range (-infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range (-infinity, infinity)
		 * @return True, if x and y is in the range [0, sizeX() - 1]x[0, sizeY() - 1]
		 */
		inline bool isInside(const TScalar x, const TScalar y) const;

		/**
		 * Returns the horizontal bin that corresponds to a precise horizontal lookup position.
		 * @param x Precise horizontal position in relation to the dimension of this lookup object, with range [0, sizeX() - 1]
		 * @return Resulting horizontal bin index
		 */
		inline size_t binX(const TScalar x) const;

		/**
		 * Returns the vertical bin that corresponds to a precise vertical lookup position.
		 * @param y Precise vertical position in relation to the dimension of this lookup object, with range [0, sizeY() - 1]
		 * @return Resulting vertical bin index
		 */
		inline size_t binY(const TScalar y) const;

		/**
		 * Returns the horizontal top left position of a specified bin with pixel accuracy.
		 * @param binX The horizontal bin position, with range [0, binsX())
		 * @return The horizontal position within the dimension of the lookup table, with range [0, sizeX())
		 */
		inline size_t binTopLeftX(const size_t binX) const;

		/**
		 * Returns the vertical top left position of a specified bin with pixel accuracy.
		 * @param binY The vertical bin position, with range [0, binsY())
		 * @return The vertical position within the dimension of the lookup table, with range [0, sizeY())
		 */
		inline size_t binTopLeftY(const size_t binY) const;

		/**
		 * Returns the horizontal bottom right position (including) of a specified bin with pixel accuracy.
		 * @param binX The horizontal bin position, with range [0, binsX())
		 * @return The horizontal position within the dimension of the lookup table, with range [0, sizeX())
		 */
		inline size_t binBottomRightX(const size_t binX) const;

		/**
		 * Returns the vertical bottom right position of a specified bin with pixel accuracy.
		 * @param binY The vertical bin position, with range [0, binsY())
		 * @return The vertical position within the dimension of the lookup table, with range [0, sizeY())
		 */
		inline size_t binBottomRightY(const size_t binY) const;

		/**
		 * Returns the horizontal center position of a specific bin in relation to the dimension of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @return Precise horizontal position of the specified bin in relation to the lookup object's dimension, with range [0, sizeX())
		 */
		inline TScalar binCenterPositionX(const size_t binX) const;

		/**
		 * Returns the vertical center position of a specific bin in relation to the dimension of this lookup object.
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @return Precise vertical position of the specified bin in relation to the lookup object's dimension, with range [0, sizeY())
		 */
		inline TScalar binCenterPositionY(const size_t binY) const;

		/**
		 * Returns the center position of a specific bin in relation to the dimension of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @return Precise position of the specified bin in relation to the lookup object's dimension, with range [0, sizeX())x[0, sizeY())
		 */
		inline Vector2 binCenterPosition(const size_t binX, const size_t binY) const;

		/**
		 * Returns the lookup value of a specific bin's center of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @return Bin lookup value
		 */
		inline const T& binCenterValue(const size_t binX, const size_t binY) const;

		/**
		 * Returns the lookup value of a specific bin's center of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @return Bin lookup value
		 */
		inline T& binCenterValue(const size_t binX, const size_t binY);

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is specified by the nearest bin (determined by the bin's center position).<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 */
		T nearestValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 */
		T bilinearValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is cubic interpolated within the 16-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 */
		T bicubicValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is specified by the nearest bin (determined by the bin's corner positions).<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @see clampedBilinearValue(), clampedBicubicValue(), nearestValue().
		 */
		T clampedNearestValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @see clampedNearestValue(), clampedBicubicValue(), bilinearValue().
		 */
		T clampedBilinearValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is cubic interpolated within the 16-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @see clampedNearestValue(), clampedBilinearValue(), bicubicValue().
		 */
		T clampedBicubicValue(const TScalar x, const TScalar y) const;

		/**
		 * Sets the value of one specific lookup bin's center.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @param value The value to be set
		 */
		inline void setBinCenterValue(const size_t binX, const size_t binY, const T& value);

		/**
		 * Move operator.
		 * @param lookup The lookup object that will be moved
		 * @return Reference to this object
		 */
		LookupCenter2<T, TScalar>& operator=(LookupCenter2<T, TScalar>&& lookup) noexcept;
};

/**
 * This class implements an advanced 2D lookup object with values at the bins' center positions defining the individual lookup values.
 * Further, this lookup object allows to define valid and invalid bins.<br>
 * Invalid bins are not used for value interpolation.<br>
 * The lookup table with e.g., 4x2 bins may have the following layout:
 * <pre>
 *   ---   ---   ---   ---
 * |  x  |  ?  |  x  |  x  |
 *   ---   ---   ---   ---
 * |  ?  |  x  |  ?  |  x  |
 *   ---   ---   ---   ---
 * </pre>
 * With 'x' showing valid center values and '?' showing invalid/undefined center values.<br>
 * Thus, the lookup table has 4 horizontal bins and 4 horizontal lookup values.<br>
 * All lookup values are located inside the specified size of the lookup object.<br>
 * The vertical positions are accordingly.
 * @tparam T The data type of the stored lookup values
 * @tparam TScalar The data type of the scalar values, either 'float' or 'double'
 * @see LookupCorner2
 * @ingroup math
 */
template <typename T, typename TScalar = Scalar>
class AdvancedLookupCenter2 : public LookupCenter2<T, TScalar>
{
	protected:

		/**
		 * Definition of a vector holding 1 byte values.
		 */
		typedef std::vector<unsigned char> ValidBins;

	public:

		/**
		 * Creates a new empty lookup object.
		 */
		AdvancedLookupCenter2() = default;

		/**
		 * Copy constructor.
		 * @param lookup The lookup object to be copied
		 */
		inline AdvancedLookupCenter2(const AdvancedLookupCenter2<T, TScalar>& lookup);

		/**
		 * Move constructor.
		 * @param lookup The lookup object to be moved
		 */
		inline AdvancedLookupCenter2(AdvancedLookupCenter2<T, TScalar>&& lookup) noexcept;

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * All bins will be set as valid.<br>
		 * Beware: The bin values will be initialized with the default constructor of the template class.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 */
		AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY);

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 * @param binsValid True, if all bins are valid; False, if all bins are invalid
		 */
		AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const bool binsValid);

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 * @param binValues The bin values of the lookup object (row aligned), binsX * binsY values must be provided
		 * @param validBins The specification whether a bin is valid or not, a zero value specifies an invalid bin, a non-zero value specifies a valid bin
		 */
		AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binValues, const unsigned char* validBins);

		/**
		 * Creates a new lookup object by definition of the dimensions and a given lookup object.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param lookup The lookup object specifying the lookup values and the number of lookup bins
		 */
		AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const AdvancedLookupCenter2<T, TScalar>& lookup);

		/**
		 * Returns whether a specific bin of this lookup object is valid.
		 * @param binX Horizontal bin position, with range [0, binsX() - 1]
		 * @param binY Vertical bin position, with range [0, binsY() - 1]
		 * @return True, if so
		 */
		inline bool binCenterValid(const size_t binX, const size_t binY) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is specified by the nearest bin (determined by the bin's center position).
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 * @param value The resulting value, if the corresponding bin is valid
		 * @return True, if the corresponding bin is valid
		 */
		bool nearestValue(const TScalar x, const TScalar y, T& value) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of valid lookup bins.<br>
		 * The interpolation result is based on valid bins only.
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 * @param value The resulting interpolated value, if at least one corresponding bin is valid
		 * @return True, if at least one corresponding bin is valid
		 */
		bool bilinearValue(const TScalar x, const TScalar y, T& value) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of valid lookup bins.<br>
		 * The interpolation result is based on valid bins only.
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX() - 1]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY() - 1]
		 * @param minimalValidBins The number of minimal valid neighboring/corresponding bins the specified position must have so that interpolation is done, with range [1, 4]
		 * @param value The resulting interpolated value, if at least one corresponding bin is valid
		 * @return True, if at least 'minimalValidBins' corresponding bin are valid
		 */
		bool bilinearValue(const TScalar x, const TScalar y, const unsigned int minimalValidBins, T& value) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is specified by the nearest bin (determined by the bin's corner positions).
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @param value The resulting value, if the corresponding bin is valid
		 * @return True, if the corresponding bin is valid
		 * @see clampedBilinearValue(), clampedBicubicValue(), nearestValue().
		 */
		bool clampedNearestValue(const TScalar x, const TScalar y, T& value) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @param value The resulting interpolated value, if at least one corresponding bin is valid
		 * @return True, if at least one corresponding bin is valid
		 * @see clampedNearestValue(), clampedBicubicValue(), bilinearValue().
		 */
		bool clampedBilinearValue(const TScalar x, const TScalar y, T& value) const;

		/**
		 * Sets the value of one specific lookup bin's center and defines whether this bin is valid.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @param value The value to be set
		 * @param isValid True, if the bin is valid; False, if the bin is invalid
		 */
		inline void setBinCenterValue(const size_t binX, const size_t binY, const T& value, const bool isValid);

		/**
		 * Sets whether a specific lookup bin is valid.
		 * @param binX Horizontal bin position, with range [0, binsX())
		 * @param binY Vertical bin position, with range [0, binsY())
		 * @param isValid True, if the bin is valid; False, if the bin is invalid
		 */
		inline void setBinCenterValid(const size_t binX, const size_t binY, const bool isValid);

		/**
		 * Move operator.
		 * @param lookup The lookup object that will be moved
		 * @return Reference to this object
		 */
		AdvancedLookupCenter2<T, TScalar>& operator=(AdvancedLookupCenter2<T, TScalar>&& lookup) noexcept;

		/**
		 * Returns whether two lookup objects are identical.
		 * @param lookup Second lookup object
		 * @return True, if so
		 */
		bool operator==(const AdvancedLookupCenter2<T, TScalar>& lookup) const;

		/**
		 * Returns whether two lookup objects are not identical.
		 * @param lookup Second lookup object
		 * @return True, if so
		 */
		inline bool operator!=(const AdvancedLookupCenter2<T, TScalar>& lookup) const;

	protected:

		/// The vector individually storing whether a bin is valid or not.
		ValidBins validBins_;
};

/**
 * This class implements a 2D lookup object with values at the bins' corners defining the individual lookup values.
 * This area is separated into individual neighboring bins (with absolute identical sizes) as each bin may cover a non-integer sized area of elements (e.g, pixels).<br>
 * Thus, the positions and sizes of a bin do not match with physical elements (e.g., pixels).
 *
 * The lookup table with 4x2 bins has the following layout:
 * <pre>
 * + --- + --- + --- + --- +
 * |     |     |     |     |
 * + --- + --- + --- + --- +
 * |     |     |     |     |
 * + --- + --- + --- + --- +
 * </pre>
 * With '+' showing the corner positions of the lookup values.<br>
 * Thus, the lookup table has 4 horizontal bins and 5 horizontal lookup values.<br>
 * The first lookup value is located at the horizontal position 0 and the last lookup value is located at the horizontal position sizeX (and not sizeX - 1).<br>
 * The vertical positions are accordingly.
 *
 * If this lookup table is applied to visual content like e.g. an image, the layout of a 4x2 bins object can be interpreted as follows:
 * <pre>
 *  -----------------------
 * |+     +     +     +    |+
 * |                       |
 * |+     +     +     +    |+
 * |                       |
 *  -----------------------
 *  +     +     +     +     +
 * </pre>
 * With '-' and '|' showing the border of the image (not covering one pixel).<br>
 * Thus, the first column of lookup values is located in the image column with index '0' while the last column of lookup values is located in the image column with index 'width' (not width - 1).<br>
 * And the first row of lookup values is located in the image row with index '0' while the last row of lookup values it located in the image row with index 'height' (not height - 1).
 * @tparam T The data type of the stored lookup values
 * @tparam TScalar The data type of the scalar values, either 'float' or 'double'
 * @see LookupCenter2
 * @ingroup math
 */
template <typename T, typename TScalar = Scalar>
class LookupCorner2 : public Lookup2<T, TScalar>
{
	public:

		/**
		 * Creates a new empty lookup object.
		 */
		LookupCorner2() = default;

		/**
		 * Copy constructor.
		 * @param lookup The lookup object to be copied
		 */
		inline LookupCorner2(const LookupCorner2<T, TScalar>& lookup);

		/**
		 * Move constructor.
		 * @param lookup The lookup object to be moved
		 */
		inline LookupCorner2(LookupCorner2<T, TScalar>&& lookup) noexcept;

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * Beware: The bin values will be initialized with the default constructor of the template class.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 */
		LookupCorner2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY);

		/**
		 * Creates a new lookup object by definition of the dimensions and bin numbers.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param binsX Number of horizontal bins, with range [1, sizeX]
		 * @param binsY Number of vertical bins, with range [1, sizeY]
		 * @param binCornerValues The bins' corner values of the lookup object (row aligned), (binsX + 1) * (binsY + 1) values must be provided
		 */
		LookupCorner2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binCornerValues);

		/**
		 * Creates a new lookup object by definition of the dimensions and a given lookup object.
		 * @param sizeX Horizontal dimension of the lookup table, with range [1, infinity)
		 * @param sizeY Vertical dimension of the lookup table, with range [1, infinity)
		 * @param lookup The lookup object specifying the lookup values and the number of lookup bins
		 */
		LookupCorner2(const size_t sizeX, const size_t sizeY, const LookupCorner2<T, TScalar>& lookup);

		/**
		 * Returns whether a given position lies inside this lookup object and therefore whether this position can be applied for the interpolation functions.
		 * @param x Precise horizontal position for the resulting lookup value, with range (-infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range (-infinity, infinity)
		 * @return True, if x and y is in the range [0, sizeX()]x[0, sizeY()]
		 */
		inline bool isInside(const TScalar x, const TScalar y) const;

		/**
		 * Returns the horizontal bin that corresponds to a precise horizontal lookup position.
		 * @param x Precise horizontal position in relation to the dimension of this lookup object, with range [0, sizeX()]
		 * @return Resulting horizontal bin index
		 */
		inline size_t binX(const TScalar x) const;

		/**
		 * Returns the vertical bin that corresponds to a precise vertical lookup position.
		 * @param y Precise vertical position in relation to the dimension of this lookup object, with range [0, sizeY()]
		 * @return Resulting vertical bin index
		 */
		inline size_t binY(const TScalar y) const;

		/**
		 * Returns the horizontal corner position of a specific bin corner (the top left corner) in relation to the dimension of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX()]
		 * @return Precise horizontal position of the specified bin in relation to the lookup object's dimension, with range [0, sizeX()]
		 */
		inline TScalar binTopLeftCornerPositionX(const size_t binX) const;

		/**
		 * Returns the vertical corner position of a specific bin corner (the top left corner) in relation to the dimension of this lookup object.
		 * @param binY Vertical bin position, with range [0, binsY()]
		 * @return Precise vertical position of the specified bin in relation to the lookup object's dimension, with range [0, sizeY()]
		 */
		inline TScalar binTopLeftCornerPositionY(const size_t binY) const;

		/**
		 * Returns the corner position (the top left corner) of a specific bin in relation to the dimension of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX()]
		 * @param binY Vertical bin position, with range [0, binsY()]
		 * @return Precise position of the specified bin in relation to the lookup object's dimension, with range [0, sizeX()]x[0, sizeY()]
		 */
		inline Vector2 binTopLeftCornerPosition(const size_t binX, const size_t binY) const;

		/**
		 * Returns the lookup value of a specific bin corner (the top left corner value) of this lookup object.
		 * @param binX Horizontal bin position, with range [0, binsX()]
		 * @param binY Vertical bin position, with range [0, binsY()]
		 * @return Bin lookup value
		 */
		inline const T& binTopLeftCornerValue(const size_t binX, const size_t binY) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is specified by the nearest bin (determined by the bin's corner positions).
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX()]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY()]
		 * @return The nearest lookup value
		 * @see bilinearValue(), bicubicValue(), clampedNearestValue().
		 */
		T nearestValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX()]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY()]
		 * @return The bilinear interpolated lookup value
		 * @see nearestValue(), bicubicValue(), clampedBilinearValue(), bilinearValues().
		 */
		T bilinearValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for an entire row in this lookup object.
		 * The resulting values are bilinear interpolated within the individual 4-neighborhood of the lookup bins.
		 * This function provides the same results as bilinearValue(), but for an entire row to speed up the computation.
		 * @param y The vertical position of the row for which the lookup values will be determined, with range [0, sizeY())
		 * @param values The resulting `sizeX()` lookup values
		 * @tparam TTarget The data type of the interpolated target values, e.g., T == VectorD2, TTarget == VectorF2
		 * @see bilinearValue().
		 */
		template <typename TTarget = T>
		void bilinearValues(const size_t y, TTarget* values) const;

		/**
		 * Applies a lookup for a subset of a row in this lookup object.
		 * The resulting values are bilinear interpolated within the individual 4-neighborhood of the lookup bins.
		 * This function provides the same results as bilinearValue(), but for a subset of the row to speed up the computation.
		 * @param x The horizontal start position for which the lookup values will be determined, with range [0, sizeX() - 1]
		 * @param y The vertical position of the row for which the lookup values will be determined, with range [0, sizeY() - 1]
		 * @param size The number of subsequent lookup values which will be created, with range [1, sizeX() - xStart]
		 * @param values The resulting `size` lookup values
		 * @tparam TTarget The data type of the interpolated target values, e.g., T == VectorD2, TTarget == VectorF2
		 * @see bilinearValue().
		 */
		template <typename TTarget = T>
		void bilinearValues(const size_t x, const size_t y, const size_t size, TTarget* values) const;

		/**
		 * Applies a lookup for a specific position in this lookup object but does not apply the bilinear interpolation, instead all necessary parameters will be returned.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX()]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY()]
		 * @param topLeft The lookup value of the top left bin (in relation to the lookup position)
		 * @param topRight The lookup value of the top right bin (in relation to the lookup position)
		 * @param bottomLeft The lookup value of the bottom left bin (in relation to the lookup position)
		 * @param bottomRight The lookup value of the bottom right bin (in relation to the lookup position)
		 * @param factorTopLeft The interpolation value for value of the top left bin, with range [0, 1]
		 * @param factorTopRight The interpolation value for value of the top right bin, with range [0, 1]
		 * @param factorBottomLeft The interpolation value for value of the bottom left bin, with range [0, 1]
		 * @param factorBottomRight The interpolation value for value of the bottom right bin, with range [0, 1]
		 * @see nearestValue(), bicubicValue(), clampedBilinearValue().
		 */
		void bilinearValue(const TScalar x, const TScalar y, T& topLeft, T& topRight, T& bottomLeft, T& bottomRight, TScalar& factorTopLeft, TScalar& factorTopRight, TScalar& factorBottomLeft, TScalar& factorBottomRight) const;

		/**
		 * Applies a lookup for a specific position in this lookup object.
		 * The resulting value is cubic interpolated within the 16-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range [0, sizeX()]
		 * @param y Precise vertical position for the resulting lookup value, with range [0, sizeY()]
		 * @return The bi-cubic interpolated lookup value
		 * @see nearestValue(), bilinearValue(), clampedBicubicValue().
		 */
		T bicubicValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is specified by the nearest bin (determined by the bin's corner positions).<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @return The nearest lookup value
		 * @see clampedBilinearValue(), clampedBicubicValue(), nearestValue().
		 */
		T clampedNearestValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is bilinear interpolated within the 4-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @return The bilinear interpolated lookup value
		 * @see clampedNearestValue(), clampedBicubicValue(), bilinearValue().
		 */
		T clampedBilinearValue(const TScalar x, const TScalar y) const;

		/**
		 * Applies a lookup for a specific position in this lookup object while the position is clamped to match into the domain of the lookup table.
		 * The resulting value is cubic interpolated within the 16-neighborhood of the lookup bins.<br>
		 * @param x Precise horizontal position for the resulting lookup value, with range -(infinity, infinity)
		 * @param y Precise vertical position for the resulting lookup value, with range -(infinity, infinity)
		 * @return The bi-cubic interpolated lookup value
		 * @see clampedNearestValue(), clampedBilinearValue(), bicubicValue().
		 */
		T clampedBicubicValue(const TScalar x, const TScalar y) const;

		/**
		 * Sets the value of one specific lookup bin's top left corner.
		 * @param binX Horizontal bin position, with range [0, binsX()]
		 * @param binY Vertical bin position, with range [0, binsY()]
		 * @param value The value to be set
		 */
		inline void setBinTopLeftCornerValue(const size_t binX, const size_t binY, const T& value);

		/**
		 * Adds an offset value to each lookup value.
		 * @param offset The offset to be added
		 * @return The new lookup object with shifted lookup values.
		 */
		LookupCorner2<T, TScalar> operator+(const T& offset) const;

		/**
		 * Adds an offset value to each lookup value.
		 * @param offset The offset to be added
		 * @return The reference to this shifted lookup object
		 */
		LookupCorner2<T, TScalar>& operator+=(const T& offset);

		/**
		 * Subtracts an offset value from each lookup value.
		 * @param offset The offset to be subtracted
		 * @return The new lookup object with shifted lookup values.
		 */
		LookupCorner2<T, TScalar> operator-(const T& offset) const;

		/**
		 * Subtracts an offset value from each lookup value.
		 * @param offset The offset to be subtracted
		 * @return The reference to this shifted lookup object
		 */
		LookupCorner2<T, TScalar>& operator-=(const T& offset);

		/**
		 * Copy operator.
		 * @param lookup The lookup object to be copied
		 * @return Reference to this object
		 */
		inline LookupCorner2<T, TScalar>& operator=(const LookupCorner2<T, TScalar>& lookup);

		/**
		 * Move operator.
		 * @param lookup The lookup object to be moved
		 * @return Reference to this object
		 */
		inline LookupCorner2<T, TScalar>& operator=(LookupCorner2<T, TScalar>&& lookup) noexcept;
};

template <typename T, typename TScalar>
inline Lookup2<T, TScalar>::Lookup2(const Lookup2<T, TScalar>& lookup) :
	sizeX_(lookup.sizeX_),
	sizeY_(lookup.sizeY_),
	binsX_(lookup.binsX_),
	binsY_(lookup.binsY_),
	invSizeX_(lookup.invSizeX_),
	invSizeY_(lookup.invSizeY_),
	invBinsX_(lookup.invBinsX_),
	invBinsY_(lookup.invBinsY_),
	values_(lookup.values_)
{
	// nothing to do here
}

template <typename T, typename TScalar>
inline Lookup2<T, TScalar>::Lookup2(Lookup2<T, TScalar>&& lookup) noexcept :
	sizeX_(lookup.sizeX_),
	sizeY_(lookup.sizeY_),
	binsX_(lookup.binsX_),
	binsY_(lookup.binsY_),
	invSizeX_(lookup.invSizeX_),
	invSizeY_(lookup.invSizeY_),
	invBinsX_(lookup.invBinsX_),
	invBinsY_(lookup.invBinsY_),
	values_(std::move(lookup.values_))
{
	lookup.sizeX_ = 0;
	lookup.sizeY_ = 0;
	lookup.binsX_ = 0;
	lookup.binsY_ = 0;

	lookup.invSizeX_ = 0;
	lookup.invSizeY_ = 0;
	lookup.invBinsX_ = 0;
	lookup.invBinsY_ = 0;
}

template <typename T, typename TScalar>
inline const T* Lookup2<T, TScalar>::data() const
{
	return values_.data();
}

template <typename T, typename TScalar>
inline T* Lookup2<T, TScalar>::data()
{
	return values_.data();
}

template <typename T, typename TScalar>
inline size_t Lookup2<T, TScalar>::sizeX() const
{
	return sizeX_;
}

template <typename T, typename TScalar>
inline size_t Lookup2<T, TScalar>::sizeY() const
{
	return sizeY_;
}

template <typename T, typename TScalar>
inline size_t Lookup2<T, TScalar>::binsX() const
{
	return binsX_;
}

template <typename T, typename TScalar>
inline size_t Lookup2<T, TScalar>::binsY() const
{
	return binsY_;
}

template <typename T, typename TScalar>
Lookup2<T, TScalar>& Lookup2<T, TScalar>::operator=(const Lookup2<T, TScalar>& lookup)
{
	sizeX_ = lookup.sizeX_;
	sizeY_ = lookup.sizeY_;
	binsX_ = lookup.binsX_;
	binsY_ = lookup.binsY_;
	invSizeX_ = lookup.invSizeX_;
	invSizeY_ = lookup.invSizeY_;
	invBinsX_ = lookup.invBinsX_;
	invBinsY_ = lookup.invBinsY_;
	values_ = lookup.values_;

	return *this;
}

template <typename T, typename TScalar>
Lookup2<T, TScalar>& Lookup2<T, TScalar>::operator=(Lookup2<T, TScalar>&& lookup) noexcept
{
	if (this != &lookup)
	{
		sizeX_ = lookup.sizeX_;
		sizeY_ = lookup.sizeY_;
		binsX_ = lookup.binsX_;
		binsY_ = lookup.binsY_;
		invSizeX_ = lookup.invSizeX_;
		invSizeY_ = lookup.invSizeY_;
		invBinsX_ = lookup.invBinsX_;
		invBinsY_ = lookup.invBinsY_;
		values_ = std::move(lookup.values_);

		lookup.sizeX_ = 0;
		lookup.sizeY_ = 0;
		lookup.binsX_ = 0;
		lookup.binsY_ = 0;
		lookup.invSizeX_ = 0;
		lookup.invSizeY_ = 0;
		lookup.invBinsX_ = 0;
		lookup.invBinsY_ = 0;
	}

	return *this;
}

template <typename T, typename TScalar>
inline bool Lookup2<T, TScalar>::isEmpty() const
{
	return values_.empty();
}

template <typename T, typename TScalar>
inline Lookup2<T, TScalar>::operator bool() const
{
	return !values_.empty();
}

template <typename T, typename TScalar>
bool Lookup2<T, TScalar>::operator==(const Lookup2<T, TScalar>& lookup) const
{
	return sizeX_ == lookup.sizeX_ && sizeY_ == lookup.sizeY_ && binsX_ == lookup.binsX_ && binsY_ == lookup.binsY_ && values_ == lookup.values_;
}

template <typename T, typename TScalar>
inline bool Lookup2<T, TScalar>::operator!=(const Lookup2<T, TScalar>& lookup) const
{
	return !(*this == lookup);
}

template <typename T, typename TScalar>
inline LookupCenter2<T, TScalar>::LookupCenter2(const LookupCenter2<T, TScalar>& lookup) :
	Lookup2<T, TScalar>(lookup)
{
	// nothing to do here
}

template <typename T, typename TScalar>
inline LookupCenter2<T, TScalar>::LookupCenter2(LookupCenter2<T, TScalar>&& lookup) noexcept :
	Lookup2<T, TScalar>(std::move(lookup))
{
	// nothing to do here
}

template <typename T, typename TScalar>
LookupCenter2<T, TScalar>::LookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY) :
	Lookup2<T, TScalar>()
{
	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = min(binsX, sizeX);
	this->binsY_ = min(binsY, sizeY);
	this->values_.resize(this->binsX_ * this->binsY_);

	ocean_assert(binsX <= sizeX);
	ocean_assert(binsY <= sizeY);

	ocean_assert(sizeX > 0);
	ocean_assert(sizeY > 0);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(binsX > 0);
	ocean_assert(binsY > 0);
	this->invBinsX_ = TScalar(1) / TScalar(binsX);
	this->invBinsY_ = TScalar(1) / TScalar(binsY);
}

template <typename T, typename TScalar>
LookupCenter2<T, TScalar>::LookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binValues) :
	Lookup2<T, TScalar>()
{
	ocean_assert(binValues);

	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = min(binsX, sizeX);
	this->binsY_ = min(binsY, sizeY);
	this->values_.resize(this->binsX_ * this->binsY_);

	ocean_assert(binsX <= sizeX);
	ocean_assert(binsY <= sizeY);

	ocean_assert(sizeX > 0);
	ocean_assert(sizeY > 0);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(binsX > 0);
	ocean_assert(binsY > 0);
	this->invBinsX_ = TScalar(1) / TScalar(binsX);
	this->invBinsY_ = TScalar(1) / TScalar(binsY);

	for (size_t n = 0; n < this->values_.size(); ++n)
	{
		this->values_[n] = binValues[n];
	}
}

template <typename T, typename TScalar>
LookupCenter2<T, TScalar>::LookupCenter2(const size_t sizeX, const size_t sizeY, const LookupCenter2<T, TScalar>& lookup) :
	Lookup2<T, TScalar>()
{
	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = lookup.binsX_;
	this->binsY_ = lookup.binsY_;
	this->values_ = lookup.values_;

	ocean_assert(this->binsX_ <= sizeX);
	ocean_assert(this->binsY_ <= sizeY);

	ocean_assert(sizeX > 0);
	ocean_assert(sizeY > 0);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(this->binsX_ > 0);
	ocean_assert(this->binsY_ > 0);
	this->invBinsX_ = TScalar(1) / TScalar(this->binsX_);
	this->invBinsY_ = TScalar(1) / TScalar(this->binsY_);
}

template <typename T, typename TScalar>
inline bool LookupCenter2<T, TScalar>::isInside(const TScalar x, const TScalar y) const
{
	ocean_assert(!this->isEmpty());
	return x >= TScalar(0) && y >= TScalar(0) && x <= TScalar(this->sizeX_ - 1) && y <= TScalar(this->sizeY_ - 1);
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binX(const TScalar x) const
{
	ocean_assert(this->sizeX_ > 0);
	ocean_assert(x >= 0 && x <= TScalar(this->sizeX_ - 1));

	const size_t result = size_t(x * TScalar(this->binsX_) * this->invSizeX_ + (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps()));
	ocean_assert(result < this->binsX_);

	return result;
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binY(const TScalar y) const
{
	ocean_assert(this->sizeY_ > 0);
	ocean_assert(y >= 0 && y <= TScalar(this->sizeY_ - 1));

	const size_t result = size_t(y * TScalar(this->binsY_) * this->invSizeY_ + (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps()));
	ocean_assert(result < this->binsY_);

	return result;
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binTopLeftX(const size_t binX) const
{
	ocean_assert(binX < this->binsX_);

	const size_t x = size_t(NumericT<TScalar>::ceil(TScalar(binX * this->sizeX_) * this->invBinsX_ - (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps())));
	ocean_assert(binX == this->binX(TScalar(x)));

	return x;
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binTopLeftY(const size_t binY) const
{
	ocean_assert(binY < this->binsY_);

	const size_t y = size_t(NumericT<TScalar>::ceil(TScalar(binY * this->sizeY_) * this->invBinsY_ - (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps())));
	ocean_assert(binY == this->binY(TScalar(y)));

	return y;
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binBottomRightX(const size_t binX) const
{
	ocean_assert(binX < this->binsX_);

	const size_t x = size_t(NumericT<TScalar>::ceil(TScalar((binX + 1) * this->sizeX_) * this->invBinsX_ - (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps())));

	ocean_assert(x >= 1);
	ocean_assert(binX == this->binX(TScalar(x - 1)));

	return x - 1;
}

template <typename T, typename TScalar>
inline size_t LookupCenter2<T, TScalar>::binBottomRightY(const size_t binY) const
{
	ocean_assert(binY < this->binsY_);

	const size_t y = size_t(NumericT<TScalar>::ceil(TScalar((binY + 1) * this->sizeY_) * this->invBinsY_ - (std::is_same<TScalar, float>::value ? TScalar(0.0001) : NumericT<TScalar>::eps())));

	ocean_assert(y >= 1);
	ocean_assert(binY == this->binY(TScalar(y - 1)));

	return y - 1;
}

template <typename T, typename TScalar>
inline TScalar LookupCenter2<T, TScalar>::binCenterPositionX(const size_t binX) const
{
	ocean_assert(binX < this->binsX_);

	const TScalar result = TScalar(binTopLeftX(binX) + binBottomRightX(binX)) * TScalar(0.5);
	ocean_assert(result >= 0 && result < TScalar(this->sizeX_));

	return result;
}

template <typename T, typename TScalar>
inline TScalar LookupCenter2<T, TScalar>::binCenterPositionY(const size_t binY) const
{
	ocean_assert(binY < this->binsY_);

	const TScalar result = TScalar(binTopLeftY(binY) + binBottomRightY(binY)) * TScalar(0.5);
	ocean_assert(result >= 0 && result < TScalar(this->sizeY_));

	return result;
}

template <typename T, typename TScalar>
inline Vector2 LookupCenter2<T, TScalar>::binCenterPosition(const size_t binX, const size_t binY) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return Vector2(binCenterPositionX(binX), binCenterPositionY(binY));
}

template <typename T, typename TScalar>
inline const T& LookupCenter2<T, TScalar>::binCenterValue(const size_t binX, const size_t binY) const
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);
	return this->values_[binY * this->binsX_ + binX];
}

template <typename T, typename TScalar>
inline T& LookupCenter2<T, TScalar>::binCenterValue(const size_t binX, const size_t binY)
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);
	return this->values_[binY * this->binsX_ + binX];
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::nearestValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->isInside(x, y));

	const size_t bx = this->binX(x);
	const size_t by = this->binY(y);

	return this->values_[by * this->binsX_ + bx];
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::bilinearValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->isInside(x, y));

	const size_t bX = this->binX(x);
	const size_t bY = this->binY(y);

	const TScalar bCenterX = this->binCenterPositionX(bX);
	const TScalar bCenterY = this->binCenterPositionY(bY);

	const size_t xLowBin = (x >= bCenterX) ? bX : max(0, int(bX) - 1);
	const size_t xHighBin = (x < bCenterX) ? bX : min(xLowBin + 1, this->binsX_ - 1);
	const size_t yLowBin = (y >= bCenterY) ? bY : max(0, int(bY) - 1);
	const size_t yHighBin = (y < bCenterY) ? bY : min(yLowBin + 1, this->binsY_ - 1);
	ocean_assert(((xLowBin == 0 || xLowBin == this->binsX_ - 1) && xHighBin == xLowBin) || xLowBin + 1 == xHighBin);
	ocean_assert(((yLowBin == 0 || yLowBin == this->binsY_ - 1) && yHighBin == yLowBin) || yLowBin + 1 == yHighBin);

	const TScalar leftCenter = this->binCenterPositionX(xLowBin);
	const TScalar rightCenter = this->binCenterPositionX(xHighBin);
	const TScalar topCenter = this->binCenterPositionY(yLowBin);
	const TScalar bottomCenter = this->binCenterPositionY(yHighBin);
	ocean_assert(leftCenter <= rightCenter);
	ocean_assert(topCenter <= bottomCenter);

	ocean_assert(xLowBin == xHighBin || (leftCenter <= x && NumericT<TScalar>::isNotEqual(leftCenter, rightCenter)));
	ocean_assert(yLowBin == yHighBin || (topCenter <= y && NumericT<TScalar>::isNotEqual(topCenter, bottomCenter)));

	const TScalar xFactor = xLowBin != xHighBin ? (x - leftCenter) / (rightCenter - leftCenter) : TScalar(1);
	const TScalar yFactor = yLowBin != yHighBin ? (y - topCenter) / (bottomCenter - topCenter) : TScalar(1);

	ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
	ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));

	const TScalar factorTopLeft = (TScalar(1) - xFactor) * (TScalar(1) - yFactor);
	const TScalar factorTopRight = xFactor * (TScalar(1) - yFactor);
	const TScalar factorBottomLeft = (TScalar(1) - xFactor) * yFactor;
	const TScalar factorBottomRight = xFactor * yFactor;

	const T& topLeft = binCenterValue(xLowBin, yLowBin);
	const T& topRight = binCenterValue(xHighBin, yLowBin);
	const T& bottomLeft = binCenterValue(xLowBin, yHighBin);
	const T& bottomRight = binCenterValue(xHighBin, yHighBin);

	return topLeft * factorTopLeft + topRight * factorTopRight
			+ bottomLeft * factorBottomLeft + bottomRight * factorBottomRight;
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::bicubicValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->isInside(x, y));

	const size_t bX = this->binX(x);
	const size_t bY = this->binY(y);

	const TScalar bCenterX = this->binCenterPositionX(bX);
	const TScalar bCenterY = this->binCenterPositionY(bY);

	const size_t xLowBin = (x >= bCenterX) ? bX : max(0, int(bX) - 1);
	const size_t xHighBin = (x < bCenterX) ? bX : min(xLowBin + 1, this->binsX_ - 1);
	const size_t yLowBin = (y >= bCenterY) ? bY : max(0, int(bY) - 1);
	const size_t yHighBin = (y < bCenterY) ? bY : min(yLowBin + 1, this->binsY_ - 1);
	ocean_assert(((xLowBin == 0 || xLowBin == this->binsX_ - 1) && xHighBin == xLowBin) || xLowBin + 1 == xHighBin);
	ocean_assert(((yLowBin == 0 || yLowBin == this->binsY_ - 1) && yHighBin == yLowBin) || yLowBin + 1 == yHighBin);

	// determine the supporting positions
	const size_t xMinusBin = max(0, int(xLowBin) - 1);
	const size_t xPlusBin = min(xHighBin + 1, this->binsX_ - 1);
	const size_t yMinusBin = max(0, int(yLowBin) - 1);
	const size_t yPlusBin = min(yHighBin + 1, this->binsY_ - 1);

	const TScalar leftCenter = this->binCenterPositionX(xLowBin);
	const TScalar rightCenter = this->binCenterPositionX(xHighBin);
	const TScalar topCenter = this->binCenterPositionY(yLowBin);
	const TScalar bottomCenter = this->binCenterPositionY(yHighBin);
	ocean_assert(leftCenter <= rightCenter);
	ocean_assert(topCenter <= bottomCenter);

	ocean_assert(xLowBin == xHighBin || (leftCenter <= x && NumericT<TScalar>::isNotEqual(leftCenter, rightCenter)));
	ocean_assert(yLowBin == yHighBin || (topCenter <= y && NumericT<TScalar>::isNotEqual(topCenter, bottomCenter)));

	const TScalar xFactor = xLowBin != xHighBin ? (x - leftCenter) / (rightCenter - leftCenter) : TScalar(1);
	const TScalar yFactor = yLowBin != yHighBin ? (y - topCenter) / (bottomCenter - topCenter) : TScalar(1);

	ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
	ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));

	return Interpolation::cubic(Interpolation::cubic(binCenterValue(xMinusBin, yMinusBin), binCenterValue(xLowBin, yMinusBin), binCenterValue(xHighBin, yMinusBin), binCenterValue(xPlusBin, yMinusBin), xFactor),
			Interpolation::cubic(binCenterValue(xMinusBin, yLowBin), binCenterValue(xLowBin, yLowBin), binCenterValue(xHighBin, yLowBin), binCenterValue(xPlusBin, yLowBin), xFactor),
			Interpolation::cubic(binCenterValue(xMinusBin, yHighBin), binCenterValue(xLowBin, yHighBin), binCenterValue(xHighBin, yHighBin), binCenterValue(xPlusBin, yHighBin), xFactor),
			Interpolation::cubic(binCenterValue(xMinusBin, yPlusBin), binCenterValue(xLowBin, yPlusBin), binCenterValue(xHighBin, yPlusBin), binCenterValue(xPlusBin, yPlusBin), xFactor), yFactor);
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::clampedNearestValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return nearestValue(minmax<TScalar>(0, x, TScalar(this->sizeX_ - 1)), minmax<TScalar>(0, y, TScalar(this->sizeY_ - 1)));
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::clampedBilinearValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return bilinearValue(minmax<TScalar>(0, x, TScalar(this->sizeX_ - 1)), minmax<TScalar>(0, y, TScalar(this->sizeY_ - 1)));
}

template <typename T, typename TScalar>
T LookupCenter2<T, TScalar>::clampedBicubicValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return bicubicValue(minmax<TScalar>(0, x, TScalar(this->sizeX_ - 1)), minmax<TScalar>(0, y, TScalar(this->sizeY_ - 1)));
}

template <typename T, typename TScalar>
inline void LookupCenter2<T, TScalar>::setBinCenterValue(const size_t binX, const size_t binY, const T& value)
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);
	this->values_[binY * this->binsX_ + binX] = value;
}

template <typename T, typename TScalar>
LookupCenter2<T, TScalar>& LookupCenter2<T, TScalar>::operator=(LookupCenter2<T, TScalar>&& lookup) noexcept
{
	Lookup2<T, TScalar>::operator=(std::move(lookup));
	return *this;
}

template <typename T, typename TScalar>
inline AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(const AdvancedLookupCenter2<T, TScalar>& lookup) :
	LookupCenter2<T, TScalar>(lookup),
	validBins_(lookup.validBins_)
{
	// nothing to do here
}

template <typename T, typename TScalar>
inline AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(AdvancedLookupCenter2<T, TScalar>&& lookup) noexcept :
	LookupCenter2<T, TScalar>(lookup),
	validBins_(std::move(lookup.validBins_))
{
	// nothing to do here
}

template <typename T, typename TScalar>
AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY) :
	LookupCenter2<T, TScalar>(sizeX, sizeY, binsX, binsY),
	validBins_(binsX * binsY, 1u)
{
	// nothing to do here
}

template <typename T, typename TScalar>
AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const bool binsValid) :
	LookupCenter2<T, TScalar>(sizeX, sizeY, binsX, binsY),
	validBins_(binsX * binsY, binsValid ? 1u : 0u)
{
	// nothing to do here
}

template <typename T, typename TScalar>
AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binValues, const unsigned char* validBins) :
	LookupCenter2<T, TScalar>(sizeX, sizeY, binsX, binsY, binValues),
	validBins_(binsX * binsY)
{
	memcpy(validBins_.data(), validBins, binsX * binsY * sizeof(unsigned char));
}

template <typename T, typename TScalar>
AdvancedLookupCenter2<T, TScalar>::AdvancedLookupCenter2(const size_t sizeX, const size_t sizeY, const AdvancedLookupCenter2<T, TScalar>& lookup) :
	LookupCenter2<T, TScalar>(sizeX, sizeY, lookup),
	validBins_(lookup.validBins_)
{
	// nothing to do here
}

template <typename T, typename TScalar>
inline bool AdvancedLookupCenter2<T, TScalar>::binCenterValid(const size_t binX, const size_t binY) const
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);
	return validBins_[binY * this->binsX_ + binX] != 0u;
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::nearestValue(const TScalar x, const TScalar y, T& value) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->values_.size() == validBins_.size());
	ocean_assert(this->isInside(x, y));

	const size_t bx = this->binX(x);
	const size_t by = this->binY(y);

	if (validBins_[by * this->binsX_ + bx] == 0u)
	{
		return false;
	}

	value = this->values_[by * this->binsX_ + bx];
	return true;
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::bilinearValue(const TScalar x, const TScalar y, T& value) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->values_.size() == validBins_.size());
	ocean_assert(this->isInside(x, y));

	const size_t bX = this->binX(x);
	const size_t bY = this->binY(y);

	const TScalar bCenterX = this->binCenterPositionX(bX);
	const TScalar bCenterY = this->binCenterPositionY(bY);

	const size_t xLowBin = (x >= bCenterX) ? bX : max(0, int(bX) - 1);
	const size_t xHighBin = (x < bCenterX) ? bX : min(xLowBin + 1, this->binsX_ - 1);
	const size_t yLowBin = (y >= bCenterY) ? bY : max(0, int(bY) - 1);
	const size_t yHighBin = (y < bCenterY) ? bY : min(yLowBin + 1, this->binsY_ - 1);
	ocean_assert(((xLowBin == 0 || xLowBin == this->binsX_ - 1) && xHighBin == xLowBin) || xLowBin + 1 == xHighBin);
	ocean_assert(((yLowBin == 0 || yLowBin == this->binsY_ - 1) && yHighBin == yLowBin) || yLowBin + 1 == yHighBin);

	const TScalar leftCenter = this->binCenterPositionX(xLowBin);
	const TScalar rightCenter = this->binCenterPositionX(xHighBin);
	const TScalar topCenter = this->binCenterPositionY(yLowBin);
	const TScalar bottomCenter = this->binCenterPositionY(yHighBin);
	ocean_assert(leftCenter <= rightCenter);
	ocean_assert(topCenter <= bottomCenter);

	ocean_assert(xLowBin == xHighBin || (leftCenter <= x && NumericT<TScalar>::isNotEqual(leftCenter, rightCenter)));
	ocean_assert(yLowBin == yHighBin || (topCenter <= y && NumericT<TScalar>::isNotEqual(topCenter, bottomCenter)));

	const TScalar xFactor = xLowBin != xHighBin ? (x - leftCenter) / (rightCenter - leftCenter) : TScalar(1);
	const TScalar yFactor = yLowBin != yHighBin ? (y - topCenter) / (bottomCenter - topCenter) : TScalar(1);

	ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
	ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));

	const T& topLeft = this->binCenterValue(xLowBin, yLowBin);
	const T& topRight = this->binCenterValue(xHighBin, yLowBin);
	const T& bottomLeft = this->binCenterValue(xLowBin, yHighBin);
	const T& bottomRight = this->binCenterValue(xHighBin, yHighBin);

	const bool validTopLeft = validBins_[yLowBin * this->binsX_ + xLowBin] != 0u;
	const bool validTopRight = validBins_[yLowBin * this->binsX_ + xHighBin] != 0u;
	const bool validBottomLeft = validBins_[yHighBin * this->binsX_ + xLowBin] != 0u;
	const bool validBottomRight = validBins_[yHighBin * this->binsX_ + xHighBin] != 0u;

	if (validTopLeft || validTopRight || validBottomLeft || validBottomRight)
	{
		value = Interpolation::bilinear(topLeft, topRight, bottomLeft, bottomRight, validTopLeft, validTopRight, validBottomLeft, validBottomRight, xFactor, yFactor);
		return true;
	}

	return false;
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::bilinearValue(const TScalar x, const TScalar y, const unsigned int minimalValidBins, T& value) const
{
	ocean_assert(minimalValidBins >= 1u && minimalValidBins <= 4u);
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->values_.size() == validBins_.size());
	ocean_assert(this->isInside(x, y));

	const size_t bX = this->binX(x);
	const size_t bY = this->binY(y);

	const TScalar bCenterX = this->binCenterPositionX(bX);
	const TScalar bCenterY = this->binCenterPositionY(bY);

	const size_t xLowBin = (x >= bCenterX) ? bX : max(0, int(bX) - 1);
	const size_t xHighBin = (x < bCenterX) ? bX : min(xLowBin + 1, this->binsX_ - 1);
	const size_t yLowBin = (y >= bCenterY) ? bY : max(0, int(bY) - 1);
	const size_t yHighBin = (y < bCenterY) ? bY : min(yLowBin + 1, this->binsY_ - 1);
	ocean_assert(((xLowBin == 0 || xLowBin == this->binsX_ - 1) && xHighBin == xLowBin) || xLowBin + 1 == xHighBin);
	ocean_assert(((yLowBin == 0 || yLowBin == this->binsY_ - 1) && yHighBin == yLowBin) || yLowBin + 1 == yHighBin);

	const TScalar leftCenter = this->binCenterPositionX(xLowBin);
	const TScalar rightCenter = this->binCenterPositionX(xHighBin);
	const TScalar topCenter = this->binCenterPositionY(yLowBin);
	const TScalar bottomCenter = this->binCenterPositionY(yHighBin);
	ocean_assert(leftCenter <= rightCenter);
	ocean_assert(topCenter <= bottomCenter);

	ocean_assert(xLowBin == xHighBin || (leftCenter <= x && NumericT<TScalar>::isNotEqual(leftCenter, rightCenter)));
	ocean_assert(yLowBin == yHighBin || (topCenter <= y && NumericT<TScalar>::isNotEqual(topCenter, bottomCenter)));

	const TScalar xFactor = xLowBin != xHighBin ? (x - leftCenter) / (rightCenter - leftCenter) : TScalar(1);
	const TScalar yFactor = yLowBin != yHighBin ? (y - topCenter) / (bottomCenter - topCenter) : TScalar(1);

	ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
	ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));

	const T& topLeft = this->binCenterValue(xLowBin, yLowBin);
	const T& topRight = this->binCenterValue(xHighBin, yLowBin);
	const T& bottomLeft = this->binCenterValue(xLowBin, yHighBin);
	const T& bottomRight = this->binCenterValue(xHighBin, yHighBin);

	const bool validTopLeft = validBins_[yLowBin * this->binsX_ + xLowBin] != 0u;
	const bool validTopRight = validBins_[yLowBin * this->binsX_ + xHighBin] != 0u;
	const bool validBottomLeft = validBins_[yHighBin * this->binsX_ + xLowBin] != 0u;
	const bool validBottomRight = validBins_[yHighBin * this->binsX_ + xHighBin] != 0u;

	ocean_assert(validTopLeft == 0 || validTopLeft == 1);
	ocean_assert(validTopRight == 0 || validTopRight == 1);
	ocean_assert(validBottomLeft == 0 || validBottomLeft == 1);
	ocean_assert(validBottomRight == 0 || validBottomRight == 1);

	if ((unsigned int)(validTopLeft + validTopRight + validBottomLeft + validBottomRight) >= minimalValidBins)
	{
		value = Interpolation::bilinear(topLeft, topRight, bottomLeft, bottomRight, validTopLeft, validTopRight, validBottomLeft, validBottomRight, xFactor, yFactor);
		return true;
	}

	return false;
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::clampedNearestValue(const TScalar x, const TScalar y, T& value) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return nearestValue(minmax<TScalar>(0, x, TScalar(this->sizeX_ - 1)), minmax<TScalar>(0, y, TScalar(this->sizeY_ - 1)), value);
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::clampedBilinearValue(const TScalar x, const TScalar y, T& value) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return bilinearValue(minmax<TScalar>(0, x, TScalar(this->sizeX_ - 1)), minmax<TScalar>(0, y, TScalar(this->sizeY_ - 1)), value);
}

template <typename T, typename TScalar>
inline void AdvancedLookupCenter2<T, TScalar>::setBinCenterValue(const size_t binX, const size_t binY, const T& value, const bool isValid)
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);

	this->values_[binY * this->binsX_ + binX] = value;
	validBins_[binY * this->binsX_ + binX] = isValid ? 1u : 0u;
}

template <typename T, typename TScalar>
inline void AdvancedLookupCenter2<T, TScalar>::setBinCenterValid(const size_t binX, const size_t binY, const bool isValid)
{
	ocean_assert(binX < this->binsX_ && binY < this->binsY_);
	validBins_[binY * this->binsX_ + binX] = isValid ? 1u: 0u;
}

template <typename T, typename TScalar>
AdvancedLookupCenter2<T, TScalar>& AdvancedLookupCenter2<T, TScalar>::operator=(AdvancedLookupCenter2<T, TScalar>&& lookup) noexcept
{
	if (this != &lookup)
	{
		LookupCenter2<T, TScalar>::operator=(std::move(lookup));
		validBins_ = std::move(lookup.validBins_);
	}

	return *this;
}

template <typename T, typename TScalar>
bool AdvancedLookupCenter2<T, TScalar>::operator==(const AdvancedLookupCenter2<T, TScalar>& lookup) const
{
	return validBins_ == lookup.validBins_ && (LookupCenter2<T, TScalar>&)*this == (LookupCenter2<T, TScalar>&)lookup;
}

template <typename T, typename TScalar>
inline bool AdvancedLookupCenter2<T, TScalar>::operator!=(const AdvancedLookupCenter2<T, TScalar>& lookup) const
{
	return !(*this == lookup);
}

template <typename T, typename TScalar>
inline LookupCorner2<T, TScalar>::LookupCorner2(const LookupCorner2<T, TScalar>& lookup) :
	Lookup2<T, TScalar>(std::move(lookup))
{
	// nothing to do here
}

template <typename T, typename TScalar>
inline LookupCorner2<T, TScalar>::LookupCorner2(LookupCorner2<T, TScalar>&& lookup) noexcept :
	Lookup2<T, TScalar>(std::move(lookup))
{
	// nothing to do here
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar>::LookupCorner2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY) :
	Lookup2<T, TScalar>()
{
	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = min(binsX, sizeX);
	this->binsY_ = min(binsY, sizeY);
	this->values_.resize((this->binsX_ + 1) * (this->binsY_ + 1));

	ocean_assert(binsX <= sizeX);
	ocean_assert(binsY <= sizeY);

	ocean_assert(sizeX >= 1);
	ocean_assert(sizeY >= 1);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(binsX > 0);
	ocean_assert(binsY > 0);
	this->invBinsX_ = TScalar(1) / TScalar(binsX);
	this->invBinsY_ = TScalar(1) / TScalar(binsY);
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar>::LookupCorner2(const size_t sizeX, const size_t sizeY, const size_t binsX, const size_t binsY, const T* binCornerValues) :
	Lookup2<T, TScalar>()
{
	ocean_assert(binCornerValues);

	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = min(binsX, sizeX);
	this->binsY_ = min(binsY, sizeY);
	this->values_.resize((this->binsX_ + 1) * (this->binsY_ + 1));

	ocean_assert(binsX <= sizeX);
	ocean_assert(binsY <= sizeY);

	ocean_assert(sizeX > 1);
	ocean_assert(sizeY > 1);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(binsX > 0);
	ocean_assert(binsY > 0);
	this->invBinsX_ = TScalar(1) / TScalar(binsX);
	this->invBinsY_ = TScalar(1) / TScalar(binsY);

	for (size_t n = 0; n < this->values_.size(); ++n)
	{
		this->values_[n] = binCornerValues[n];
	}
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar>::LookupCorner2(const size_t sizeX, const size_t sizeY, const LookupCorner2<T, TScalar>& lookup) :
	Lookup2<T, TScalar>()
{
	this->sizeX_ = sizeX;
	this->sizeY_ = sizeY;
	this->binsX_ = lookup.binsX_;
	this->binsY_ = lookup.binsY_;
	this->values_ = lookup.values_;

	ocean_assert(this->binsX_ <= sizeX);
	ocean_assert(this->binsY_ <= sizeY);

	ocean_assert(sizeX > 1);
	ocean_assert(sizeY > 1);
	this->invSizeX_ = TScalar(1) / TScalar(sizeX);
	this->invSizeY_ = TScalar(1) / TScalar(sizeY);

	ocean_assert(this->binsX_ > 0);
	ocean_assert(this->binsY_ > 0);
	this->invBinsX_ = TScalar(1) / TScalar(this->binsX_);
	this->invBinsY_ = TScalar(1) / TScalar(this->binsY_);
}

template <typename T, typename TScalar>
inline bool LookupCorner2<T, TScalar>::isInside(const TScalar x, const TScalar y) const
{
	ocean_assert(!this->isEmpty());
	return x >= TScalar(0) && y >= TScalar(0) && x <= TScalar(this->sizeX_) && y <= TScalar(this->sizeY_);
}

template <typename T, typename TScalar>
inline size_t LookupCorner2<T, TScalar>::binX(const TScalar x) const
{
	ocean_assert(this->sizeX_ > 0);
	ocean_assert(x >= 0 && x <= TScalar(this->sizeX_));

	const size_t result = size_t(x * TScalar(this->binsX_) * this->invSizeX_);
	ocean_assert(result <= this->binsX_);

	return result;
}

template <typename T, typename TScalar>
inline size_t LookupCorner2<T, TScalar>::binY(const TScalar y) const
{
	ocean_assert(this->sizeY_ > 0);
	ocean_assert(y >= 0 && y <= TScalar(this->sizeY_));

	const size_t result = size_t(y * TScalar(this->binsY_) * this->invSizeY_);
	ocean_assert(result <= this->binsY_);

	return result;
}

template <typename T, typename TScalar>
inline TScalar LookupCorner2<T, TScalar>::binTopLeftCornerPositionX(const size_t binX) const
{
	ocean_assert(binX <= this->binsX_ && this->sizeX_ >= 1);

	const TScalar result = TScalar(binX * this->sizeX_) * this->invBinsX_;

	// the clamping is necessary due to tiny rounding issues
	return minmax<TScalar>(0, result, TScalar(this->sizeX_));
}

template <typename T, typename TScalar>
inline TScalar LookupCorner2<T, TScalar>::binTopLeftCornerPositionY(const size_t binY) const
{
	ocean_assert(binY <= this->binsY_ && this->sizeY_ >= 1);

	const TScalar result = TScalar(binY * this->sizeY_) * this->invBinsY_;

	// the clamping is necessary due to tiny rounding issues
	return minmax<TScalar>(0, result, TScalar(this->sizeY_));
}

template <typename T, typename TScalar>
inline Vector2 LookupCorner2<T, TScalar>::binTopLeftCornerPosition(const size_t binX, const size_t binY) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return Vector2(binTopLeftCornerPositionX(binX), binTopLeftCornerPositionY(binY));
}

template <typename T, typename TScalar>
inline const T& LookupCorner2<T, TScalar>::binTopLeftCornerValue(const size_t binX, const size_t binY) const
{
	ocean_assert(binX <= this->binsX_ && binY <= this->binsY_);
	return this->values_[binY * (this->binsX_ + 1) + binX];
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::nearestValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->isInside(x, y));

	const size_t bx = size_t(x * TScalar(this->binsX_) * this->invSizeX_ + TScalar(0.5));
	ocean_assert(bx <= this->binsX_);

	const size_t by = size_t(y * TScalar(this->binsY_) * this->invSizeY_ + TScalar(0.5));
	ocean_assert(by <= this->binsY_);

	return this->values_[by * (this->binsX_ + 1) + bx];
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::bilinearValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->isInside(x, y));

	const size_t xLowBin = this->binX(x);
	const size_t yLowBin = this->binY(y);

	ocean_assert(xLowBin <= this->binsX_);
	ocean_assert(yLowBin <= this->binsY_);

	const TScalar leftPosition = this->binTopLeftCornerPositionX(xLowBin);
	const TScalar topPosition = this->binTopLeftCornerPositionY(yLowBin);

	const TScalar xFactor = (x - leftPosition) * TScalar(this->binsX_) * this->invSizeX_;
	const TScalar yFactor = (y - topPosition) * TScalar(this->binsY_) * this->invSizeY_;

#ifdef OCEAN_DEBUG
	if (std::is_same<TScalar, float>::value)
	{
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, yFactor, 1));
	}
	else
	{
		ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));
	}
#endif

	const TScalar factorTopLeft = (TScalar(1) - xFactor) * (TScalar(1) - yFactor);
	const TScalar factorTopRight = xFactor * (TScalar(1) - yFactor);
	const TScalar factorBottomLeft = (TScalar(1) - xFactor) * yFactor;
	const TScalar factorBottomRight = xFactor * yFactor;

	const size_t xHighBin = min(xLowBin + 1, this->binsX_);
	const size_t yHighBin = min(yLowBin + 1, this->binsY_);

	const T& topLeft = this->binTopLeftCornerValue(xLowBin, yLowBin);
	const T& topRight = this->binTopLeftCornerValue(xHighBin, yLowBin);
	const T& bottomLeft = this->binTopLeftCornerValue(xLowBin, yHighBin);
	const T& bottomRight = this->binTopLeftCornerValue(xHighBin, yHighBin);

	return topLeft * factorTopLeft + topRight * factorTopRight
			+ bottomLeft * factorBottomLeft + bottomRight * factorBottomRight;
}

template <typename T, typename TScalar>
template <typename TTarget>
void LookupCorner2<T, TScalar>::bilinearValues(const size_t y, TTarget* values) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->binsX_ <= this->sizeX_ && this->binsY_ <= this->sizeY_);

	ocean_assert(y < this->sizeY_);
	ocean_assert(values != nullptr);

	const size_t yLowBin = (y * this->binsY_) / this->sizeY_;
	ocean_assert(yLowBin < this->binsY_);
	ocean_assert(std::abs(int(yLowBin) - int(this->binY(TScalar(y)))) <= 1);

	const size_t yHighBin = yLowBin + 1;
	ocean_assert(yHighBin <= this->binsY_);

	const TScalar yLowBinPosition = this->binTopLeftCornerPositionY(yLowBin);
	const TScalar yHighBinPosition = this->binTopLeftCornerPositionY(yHighBin);
	ocean_assert(yLowBinPosition < yHighBinPosition);

	const TScalar yFactor = (TScalar(y) - yLowBinPosition) / (yHighBinPosition - yLowBinPosition);
	ocean_assert(NumericT<TScalar>::isInsideWeakRange(TScalar(0), yFactor, TScalar(1)));

	const Vector2* lowBinValues = this->values_.data() + (yLowBin * (this->binsX_ + 1));
	const Vector2* highBinValues = this->values_.data() + (yHighBin * (this->binsX_ + 1));

	Vector2 leftBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;
	Vector2 rightBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;

	unsigned int nextBinX = 1u;

	TScalar leftBinPositionX = TScalar(0);
	TScalar rightBinPositionX = TScalar(nextBinX++ * this->sizeX_) * this->invBinsX_;

	ocean_assert(rightBinPositionX - leftBinPositionX > NumericT<TScalar>::eps());
	TScalar invBinWidthX = TScalar(1) / (rightBinPositionX - leftBinPositionX);

	for (size_t x = 0; x < this->sizeX_; ++x)
	{
		if (TScalar(x) > rightBinPositionX)
		{
			leftBinValue = rightBinValue;
			rightBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;

			leftBinPositionX = rightBinPositionX;
			rightBinPositionX = TScalar(nextBinX++ * this->sizeX_) * this->invBinsX_;

			ocean_assert(rightBinPositionX - leftBinPositionX > NumericT<TScalar>::eps());
			invBinWidthX = TScalar(1) / (rightBinPositionX - leftBinPositionX);
		}

		ocean_assert(leftBinPositionX <= TScalar(x));

		const TScalar xFactor = (TScalar(x) - leftBinPositionX) * invBinWidthX;

		if constexpr (std::is_same<TScalar, float>::value)
		{
			ocean_assert(NumericT<TScalar>::isInsideWeakRange(TScalar(0), xFactor, TScalar(1)));
		}
		else
		{
			ocean_assert(NumericT<TScalar>::isInsideRange(TScalar(0), xFactor, TScalar(1)));
		}

		values[x] = TTarget(leftBinValue * (TScalar(1) - xFactor) + rightBinValue * xFactor);

#ifdef OCEAN_DEBUG
		const T debugTestValue = this->bilinearValue(TScalar(x), TScalar(y));
		const TScalar debugError = debugTestValue.distance(T(values[x]));
		ocean_assert(debugError < TScalar(0.1));
#endif
	}
}

template <typename T, typename TScalar>
template <typename TTarget>
void LookupCorner2<T, TScalar>::bilinearValues(const size_t x, const size_t y, const size_t size, TTarget* values) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->binsX_ <= this->sizeX_ && this->binsY_ <= this->sizeY_);

	ocean_assert(x + size <= this->sizeX_);

	ocean_assert(y < this->sizeY_);
	ocean_assert(values != nullptr);

	ocean_assert(size >= 1);

	const size_t xLowBin = (x * this->binsX_) / this->sizeX_;
	ocean_assert(xLowBin < this->binsX_);
	ocean_assert(std::abs(int(xLowBin) - int(this->binX(TScalar(x)))) <= 1);

	const size_t yLowBin = (y * this->binsY_) / this->sizeY_;
	ocean_assert(yLowBin < this->binsY_);
	ocean_assert(std::abs(int(yLowBin) - int(this->binY(TScalar(y)))) <= 1);

	const size_t yHighBin = yLowBin + 1;
	ocean_assert(yHighBin <= this->binsY_);

	const TScalar yLowBinPosition = this->binTopLeftCornerPositionY(yLowBin);
	const TScalar yHighBinPosition = this->binTopLeftCornerPositionY(yHighBin);
	ocean_assert(yLowBinPosition < yHighBinPosition);

	const TScalar yFactor = (TScalar(y) - yLowBinPosition) / (yHighBinPosition - yLowBinPosition);
	ocean_assert(NumericT<TScalar>::isInsideWeakRange(TScalar(0), yFactor, TScalar(1)));

	const Vector2* lowBinValues = this->values_.data() + (yLowBin * (this->binsX_ + 1)) + xLowBin;
	const Vector2* highBinValues = this->values_.data() + (yHighBin * (this->binsX_ + 1)) + xLowBin;

	Vector2 leftBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;
	Vector2 rightBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;

	size_t nextBinX = xLowBin + 1u;

	TScalar leftBinPositionX = TScalar(xLowBin * this->sizeX_) * this->invBinsX_;
	TScalar rightBinPositionX = TScalar(nextBinX++ * this->sizeX_) * this->invBinsX_;

	ocean_assert(rightBinPositionX - leftBinPositionX > NumericT<TScalar>::eps());
	TScalar invBinWidthX = TScalar(1) / (rightBinPositionX - leftBinPositionX);

	for (size_t nX = x; nX < x + size; ++nX)
	{
		if (TScalar(nX) > rightBinPositionX)
		{
			leftBinValue = rightBinValue;
			rightBinValue = *lowBinValues++ * (TScalar(1) - yFactor) + *highBinValues++ * yFactor;

			leftBinPositionX = rightBinPositionX;
			rightBinPositionX = TScalar(nextBinX++ * this->sizeX_) * this->invBinsX_;

			ocean_assert(rightBinPositionX - leftBinPositionX > NumericT<TScalar>::eps());
			invBinWidthX = TScalar(1) / (rightBinPositionX - leftBinPositionX);
		}

		ocean_assert(leftBinPositionX <= TScalar(nX) + NumericT<TScalar>::weakEps());

		const TScalar xFactor = (TScalar(nX) - leftBinPositionX) * invBinWidthX;
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(TScalar(0), xFactor, TScalar(1)));

		*values++ = TTarget(leftBinValue * (TScalar(1) - xFactor) + rightBinValue * xFactor);

#ifdef OCEAN_DEBUG
		const T debugTestValue = this->bilinearValue(TScalar(nX), TScalar(y));
		const TScalar debugError = debugTestValue.distance(T(TTarget(leftBinValue * (TScalar(1) - xFactor) + rightBinValue * xFactor)));
		ocean_assert(debugError < TScalar(0.1));
#endif
	}
}

template <typename T, typename TScalar>
void LookupCorner2<T, TScalar>::bilinearValue(const TScalar x, const TScalar y, T& topLeft, T& topRight, T& bottomLeft, T& bottomRight, TScalar& factorTopLeft, TScalar& factorTopRight, TScalar& factorBottomLeft, TScalar& factorBottomRight) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->isInside(x, y));

	const size_t xLowBin = this->binX(x);
	const size_t yLowBin = this->binY(y);

	ocean_assert(xLowBin <= this->binsX_);
	ocean_assert(yLowBin <= this->binsY_);

	const TScalar leftPosition = this->binTopLeftCornerPositionX(xLowBin);
	const TScalar topPosition = this->binTopLeftCornerPositionY(yLowBin);

	const TScalar xFactor = (x - leftPosition) * TScalar(this->binsX_) * this->invSizeX_;
	const TScalar yFactor = (y - topPosition) * TScalar(this->binsY_) * this->invSizeY_;

#ifdef OCEAN_DEBUG
	if (std::is_same<TScalar, float>::value)
	{
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, yFactor, 1));
	}
	else
	{
		ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));
	}
#endif

	factorTopLeft = (TScalar(1) - xFactor) * (TScalar(1) - yFactor);
	factorTopRight = xFactor * (TScalar(1) - yFactor);
	factorBottomLeft = (TScalar(1) - xFactor) * yFactor;
	factorBottomRight = xFactor * yFactor;

	const size_t xHighBin = min(xLowBin + 1, this->binsX_);
	const size_t yHighBin = min(yLowBin + 1, this->binsY_);

	topLeft = this->binTopLeftCornerValue(xLowBin, yLowBin);
	topRight = this->binTopLeftCornerValue(xHighBin, yLowBin);
	bottomLeft = this->binTopLeftCornerValue(xLowBin, yHighBin);
	bottomRight = this->binTopLeftCornerValue(xHighBin, yHighBin);
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::bicubicValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);
	ocean_assert(this->isInside(x, y));

	const size_t xLowBin = this->binX(x);
	const size_t yLowBin = this->binY(y);

	ocean_assert(xLowBin <= this->binsX_);
	ocean_assert(yLowBin <= this->binsY_);

	const TScalar leftPosition = this->binTopLeftCornerPositionX(xLowBin);
	const TScalar topPosition = this->binTopLeftCornerPositionY(yLowBin);

	const TScalar xFactor = (x - leftPosition) * TScalar(this->binsX_) * this->invSizeX_;
	const TScalar yFactor = (y - topPosition) * TScalar(this->binsY_) * this->invSizeY_;

#ifdef OCEAN_DEBUG
	if (std::is_same<TScalar, float>::value)
	{
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideWeakRange(0, yFactor, 1));
	}
	else
	{
		ocean_assert(NumericT<TScalar>::isInsideRange(0, xFactor, 1));
		ocean_assert(NumericT<TScalar>::isInsideRange(0, yFactor, 1));
	}
#endif

	const size_t xHighBin = min(xLowBin + 1, this->binsX_);
	const size_t yHighBin = min(yLowBin + 1, this->binsY_);

	// determine the supporting positions
	const size_t xMinusBin = max(0, int(xLowBin) - 1);
	const size_t xPlusBin = min(xLowBin + 2, this->binsX_);
	const size_t yMinusBin = max(0, int(yLowBin) - 1);
	const size_t yPlusBin = min(yLowBin + 2, this->binsY_);

	return Interpolation::cubic(Interpolation::cubic(binTopLeftCornerValue(xMinusBin, yMinusBin), binTopLeftCornerValue(xLowBin, yMinusBin), binTopLeftCornerValue(xHighBin, yMinusBin), binTopLeftCornerValue(xPlusBin, yMinusBin), xFactor),
			Interpolation::cubic(binTopLeftCornerValue(xMinusBin, yLowBin), binTopLeftCornerValue(xLowBin, yLowBin), binTopLeftCornerValue(xHighBin, yLowBin), binTopLeftCornerValue(xPlusBin, yLowBin), xFactor),
			Interpolation::cubic(binTopLeftCornerValue(xMinusBin, yHighBin), binTopLeftCornerValue(xLowBin, yHighBin), binTopLeftCornerValue(xHighBin, yHighBin), binTopLeftCornerValue(xPlusBin, yHighBin), xFactor),
			Interpolation::cubic(binTopLeftCornerValue(xMinusBin, yPlusBin), binTopLeftCornerValue(xLowBin, yPlusBin), binTopLeftCornerValue(xHighBin, yPlusBin), binTopLeftCornerValue(xPlusBin, yPlusBin), xFactor), yFactor);
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::clampedNearestValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return nearestValue(minmax<TScalar>(0, x, TScalar(this->sizeX_)), minmax<TScalar>(0, y, TScalar(this->sizeY_)));
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::clampedBilinearValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return bilinearValue(minmax<TScalar>(0, x, TScalar(this->sizeX_)), minmax<TScalar>(0, y, TScalar(this->sizeY_)));
}

template <typename T, typename TScalar>
T LookupCorner2<T, TScalar>::clampedBicubicValue(const TScalar x, const TScalar y) const
{
	ocean_assert(this->binsX_ > 0 && this->binsY_ > 0);

	return bicubicValue(minmax<TScalar>(0, x, TScalar(this->sizeX_)), minmax<TScalar>(0, y, TScalar(this->sizeY_)));
}

template <typename T, typename TScalar>
inline void LookupCorner2<T, TScalar>::setBinTopLeftCornerValue(const size_t binX, const size_t binY, const T& value)
{
	ocean_assert(binX <= this->binsX_ && binY <= this->binsY_);
	this->values_[binY * (this->binsX_ + 1) + binX] = value;
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar> LookupCorner2<T, TScalar>::operator+(const T& offset) const
{
	LookupCorner2<T, TScalar> result(*this);

	for (size_t n = 0; n < result.values_.size(); ++n)
	{
		result.values_[n] += offset;
	}

	return result;
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar>& LookupCorner2<T, TScalar>::operator+=(const T& offset)
{
	for (size_t n = 0; n < this->values_.size(); ++n)
	{
		this->values_[n] += offset;
	}

	return *this;
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar> LookupCorner2<T, TScalar>::operator-(const T& offset) const
{
	LookupCorner2<T, TScalar> result(*this);

	for (size_t n = 0; n < result.values_.size(); ++n)
	{
		result.values_[n] -= offset;
	}

	return result;
}

template <typename T, typename TScalar>
LookupCorner2<T, TScalar>& LookupCorner2<T, TScalar>::operator-=(const T& offset)
{
	for (size_t n = 0; n < this->values_.size(); ++n)
	{
		this->values_[n] -= offset;
	}

	return *this;
}

template <typename T, typename TScalar>
inline LookupCorner2<T, TScalar>& LookupCorner2<T, TScalar>::operator=(const LookupCorner2<T, TScalar>& lookup)
{
	Lookup2<T, TScalar>::operator=(lookup);
	return *this;
}

template <typename T, typename TScalar>
inline LookupCorner2<T, TScalar>& LookupCorner2<T, TScalar>::operator=(LookupCorner2<T, TScalar>&& lookup) noexcept
{
	Lookup2<T, TScalar>::operator=(std::move(lookup));
	return *this;
}

}

#endif // META_OCEAN_MATH_LOOKUP2_H
