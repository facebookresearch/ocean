<?xml version="1.0" encoding="utf-8"?>
<!--
  Ocean Android Application - Shared MSBuild Targets

  This file provides common build targets for Ocean Android Application projects.
  It handles integration between Android app projects (C# or VC++ Makefile) and
  native C++ libraries built with the OceanNDK toolset.

  Supports both project types:
  - C# projects: hooks into CoreBuild/CoreClean
  - VC++ Makefile projects: hooks into Build/Clean

  To use in your project, add this import after Microsoft.CSharp.targets or Microsoft.Cpp.targets:
    <Import Project="$(OceanAndroidExtensionPath)\toolset\OceanAndroidApp\OceanAndroidApp.targets"
            Condition="Exists('$(OceanAndroidExtensionPath)\toolset\OceanAndroidApp\OceanAndroidApp.targets')" />
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- ============================================================
       Default metadata for OceanNativeSharedLibrary items

       Automatically displays native libraries in a "dependencies"
       virtual folder in Solution Explorer.
       ============================================================ -->
  <ItemDefinitionGroup>
    <OceanNativeSharedLibrary>
      <Link>dependencies\%(Filename)%(Extension)</Link>
    </OceanNativeSharedLibrary>
  </ItemDefinitionGroup>

  <!-- Create None items from OceanNativeSharedLibrary for Solution Explorer display -->
  <!-- VS doesn't display custom item types with <Link>, so we create matching None items -->
  <ItemGroup>
    <None Include="@(OceanNativeSharedLibrary)">
      <Link>dependencies\%(Filename)%(Extension)</Link>
    </None>
  </ItemGroup>

  <!-- ============================================================
       Property Page Schemas

       Registers the AndroidManifest item type so it appears in the
       VS Property Pages "Item Type" dropdown when right-clicking files.
       ============================================================ -->
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)PropertyPages\AndroidManifest.xml">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(MSBuildThisFileDirectory)PropertyPages\OceanAndroidApp.General.xml')">
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)PropertyPages\OceanAndroidApp.General.xml" />
  </ItemGroup>

  <!-- ============================================================
       Extension Path Detection
       ============================================================ -->
  <PropertyGroup>
    <!-- Try to locate the extension path from registry (set by VSIX installation) -->
    <OceanAndroidExtensionPath Condition="'$(OceanAndroidExtensionPath)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\17.0\MSBuild\OceanAndroidExtension', 'ExtensionPath', '', RegistryView.Default))</OceanAndroidExtensionPath>

    <!-- Fallback: Relative to this file (for development/testing) -->
    <OceanAndroidExtensionPath Condition="'$(OceanAndroidExtensionPath)' == ''">$(MSBuildThisFileDirectory)..\..\..</OceanAndroidExtensionPath>
  </PropertyGroup>

  <!-- ============================================================
       Android Manifest Default
       ============================================================ -->
  <PropertyGroup>
    <AndroidManifestFile Condition="'$(AndroidManifestFile)' == ''">$(MSBuildProjectDirectory)\app\AndroidManifest.xml</AndroidManifestFile>
  </PropertyGroup>

  <!-- ============================================================
       APK Output and NMake Output

       ApkOutputPath is the Gradle APK output directory.
       NMakeOutput tells VS what the build output file is.
       ============================================================ -->
  <PropertyGroup>
    <ApkOutputPath Condition="'$(ApkOutputPath)' == ''">$(GradleBuildDir)\outputs\apk</ApkOutputPath>
    <NMakeOutput Condition="'$(NMakeOutput)' == ''">$(ApkOutputPath)\debug\app-debug.apk</NMakeOutput>
    <NMakeOutput Condition="'$(Configuration)' == 'Release'">$(ApkOutputPath)\release\app-release.apk</NMakeOutput>
  </PropertyGroup>

  <!-- ============================================================
       Debug/Start Settings

       F5 runs deploy.bat to install and launch via ADB.
       ============================================================ -->
  <PropertyGroup>
    <LocalDebuggerCommand Condition="'$(LocalDebuggerCommand)' == ''">$(MSBuildProjectDirectory)\gradle\deploy.bat</LocalDebuggerCommand>
    <LocalDebuggerCommandArguments Condition="'$(LocalDebuggerCommandArguments)' == '' AND $(Configuration.Contains('Release'))">"$(MSBuildProjectDirectory)" "$(AndroidPackageName)" "$(ApkOutputPath)\release\app-release.apk"</LocalDebuggerCommandArguments>
    <LocalDebuggerCommandArguments Condition="'$(LocalDebuggerCommandArguments)' == '' AND !$(Configuration.Contains('Release'))">"$(MSBuildProjectDirectory)" "$(AndroidPackageName)" "$(ApkOutputPath)\debug\app-debug.apk"</LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory Condition="'$(LocalDebuggerWorkingDirectory)' == ''">$(MSBuildProjectDirectory)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor Condition="'$(DebuggerFlavor)' == ''">WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>

  <!-- ============================================================
       CopyNativeLibsToJniLibs Target

       Copies .so libraries declared in @(OceanNativeSharedLibrary) to the
       jniLibs folder before Gradle builds the APK.

       To use this, your Android app project must import the _use.props
       files from any shared native libraries it depends on. For example:

         <ImportGroup Label="NativeLibraryDependencies">
           <Import Project="..\MyWrapper\MyWrapper_use.props" />
         </ImportGroup>

       The _use.props file for shared libraries declares OceanNativeSharedLibrary
       items which this target picks up and copies to jniLibs/<abi>/.

       Static libraries (.a) don't need to be copied - they're linked into
       the shared library at compile time.
       ============================================================ -->
  <Target Name="CopyNativeLibsToJniLibs"
          BeforeTargets="CoreBuild;Build"
          Condition="'@(OceanNativeSharedLibrary)' != ''">

    <!-- Determine jniLibs destination based on ABI -->
    <!-- Only set if not already defined (allows project-level override) -->
    <!-- Uses simplified folder structure: app/jniLibs/ instead of app/src/main/jniLibs/ -->
    <PropertyGroup Condition="'$(JniLibsDir)' == ''">
      <JniLibsDir>$(MSBuildProjectDirectory)\app\jniLibs\$(AndroidAbi)</JniLibsDir>
    </PropertyGroup>

    <!-- Create jniLibs directory if needed -->
    <MakeDir Directories="$(JniLibsDir)" />

    <!-- Copy native libraries -->
    <Copy SourceFiles="@(OceanNativeSharedLibrary)"
          DestinationFolder="$(JniLibsDir)"
          SkipUnchangedFiles="true">
      <Output TaskParameter="CopiedFiles" ItemName="_CopiedNativeLibs" />
    </Copy>

    <Message Text="[OceanAndroid] Copied native library to jniLibs: %(_CopiedNativeLibs.Identity)"
             Importance="high"
             Condition="'@(_CopiedNativeLibs)' != ''" />
  </Target>

  <!-- ============================================================
       CleanNativeLibsFromJniLibs Target

       Removes copied native libraries during clean.
       ============================================================ -->
  <Target Name="CleanNativeLibsFromJniLibs"
          AfterTargets="CoreClean;Clean"
          Condition="'@(ProjectReference)' != ''">

    <!-- Get the jniLibs directory for the current ABI -->
    <!-- Only set if not already defined (allows project-level override) -->
    <!-- Uses simplified folder structure: app/jniLibs/ instead of app/src/main/jniLibs/ -->
    <PropertyGroup Condition="'$(JniLibsDir)' == ''">
      <JniLibsDir>$(MSBuildProjectDirectory)\app\jniLibs\$(AndroidAbi)</JniLibsDir>
    </PropertyGroup>

    <!-- Remove the ABI-specific jniLibs directory -->
    <RemoveDir Directories="$(JniLibsDir)" Condition="Exists('$(JniLibsDir)')" />

    <Message Text="[OceanAndroid] Cleaned jniLibs for $(AndroidAbi)"
             Importance="normal"
             Condition="Exists('$(JniLibsDir)')" />
  </Target>

  <!-- ============================================================
       Native Library Resolution via ProjectReference

       Builds referenced native library projects, extracts .so outputs,
       and copies them to the jniLibs staging directory for Gradle.
       This complements CopyNativeLibsToJniLibs (which handles
       OceanNativeSharedLibrary items from _use.props imports).
       ============================================================ -->

  <Target Name="_ResolveAndCopyNativeLibraries"
          BeforeTargets="Build"
          Condition="'@(ProjectReference)' != ''">

    <Message Text="========================================" Importance="high" />
    <Message Text="Resolving native library references..." Importance="high" />
    <Message Text="  Platform: $(Platform) ($(AndroidAbi))" Importance="normal" />

    <!-- Build referenced native library projects -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="Build"
             Properties="Configuration=$(Configuration);Platform=$(Platform)"
             BuildInParallel="true" />

    <!-- Get output paths from referenced projects -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="GetTargetPath"
             Properties="Configuration=$(Configuration);Platform=$(Platform)">
      <Output TaskParameter="TargetOutputs" ItemName="_NativeLibraryOutputs" />
    </MSBuild>

    <!-- Filter to .so files only -->
    <ItemGroup>
      <_SoFilesToCopy Include="@(_NativeLibraryOutputs)"
                      Condition="'%(Extension)' == '.so'" />
    </ItemGroup>

    <!-- Create jniLibs staging directory -->
    <MakeDir Directories="$(JniLibsStagingDir)\$(AndroidAbi)"
             Condition="'@(_SoFilesToCopy)' != ''" />

    <!-- Copy .so files to jniLibs staging directory -->
    <Copy SourceFiles="@(_SoFilesToCopy)"
          DestinationFolder="$(JniLibsStagingDir)\$(AndroidAbi)"
          SkipUnchangedFiles="true"
          Condition="'@(_SoFilesToCopy)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="_CopiedNativeLibs" />
    </Copy>

    <Message Text="  Copied: @(_CopiedNativeLibs->'%(Filename)%(Extension)', ', ')"
             Importance="high"
             Condition="'@(_CopiedNativeLibs)' != ''" />
    <Message Text="  Destination: $(JniLibsStagingDir)\$(AndroidAbi)\"
             Importance="normal"
             Condition="'@(_CopiedNativeLibs)' != ''" />
    <Message Text="========================================" Importance="high" />
  </Target>

  <Target Name="_CleanNativeLibraries" BeforeTargets="Clean">
    <ItemGroup>
      <_JniLibsToDelete Include="$(MSBuildProjectDirectory)\app\src\main\jniLibs\**\*.so" />
    </ItemGroup>
    <Delete Files="@(_JniLibsToDelete)" ContinueOnError="true" />
  </Target>

  <!-- ============================================================
       Java Library References

       Discovers referenced Android Java Library projects and stages
       their Java sources before Gradle builds the application.
       ============================================================ -->

  <!-- Resolve Java Library references -->
  <Target Name="_ResolveJavaLibraryReferences"
          BeforeTargets="StageJavaSources"
          Condition="'@(ProjectReference)' != ''">

    <!-- Get IsAndroidJavaLibrary property from referenced projects -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="GetPropertyValue"
             Properties="PropertyName=IsAndroidJavaLibrary"
             ContinueOnError="true">
      <Output TaskParameter="TargetOutputs" ItemName="_JavaLibraryCheckOutputs" />
    </MSBuild>

    <!-- Filter to only Java library projects -->
    <ItemGroup>
      <_JavaLibraryProjects Include="@(ProjectReference)"
                            Condition="'%(ProjectReference.IsAndroidJavaLibrary)' == 'true'" />
    </ItemGroup>

    <Message Text="[$(ProjectName)] Found Java library references: @(_JavaLibraryProjects->'%(Filename)', ', ')"
             Importance="high"
             Condition="'@(_JavaLibraryProjects)' != ''" />
  </Target>

  <!-- Stage Java sources from referenced libraries -->
  <Target Name="_StageJavaLibrarySources"
          BeforeTargets="Build"
          AfterTargets="StageJavaSources"
          Condition="'@(ProjectReference)' != ''">

    <Message Text="========================================" Importance="high" />
    <Message Text="Staging Java library sources..." Importance="high" />

    <!-- Build referenced Java library projects (triggers their StageJavaSources) -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="StageJavaSources"
             Properties="Configuration=$(Configuration);Platform=$(Platform)"
             Condition="'%(ProjectReference.IsAndroidJavaLibrary)' == 'true'"
             ContinueOnError="true" />

    <!-- Get staged Java sources from each library -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="GetJavaStagingPath"
             Properties="Configuration=$(Configuration);Platform=$(Platform)"
             Condition="'%(ProjectReference.IsAndroidJavaLibrary)' == 'true'"
             ContinueOnError="true">
      <Output TaskParameter="TargetOutputs" ItemName="_JavaLibStagedDirs" />
    </MSBuild>

    <!-- Copy library staged sources into app's staging directory -->
    <!-- This merges all library sources with app sources for Gradle -->
    <ItemGroup Condition="'@(_JavaLibStagedDirs)' != ''">
      <_LibraryStagedFiles Include="%(_JavaLibStagedDirs.Identity)\**\*.java" />
    </ItemGroup>

    <Copy SourceFiles="@(_LibraryStagedFiles)"
          DestinationFiles="@(_LibraryStagedFiles->'$(JavaStagingDir)\%(RecursiveDir)%(Filename)%(Extension)')"
          SkipUnchangedFiles="true"
          Condition="'@(_LibraryStagedFiles)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="_CopiedLibraryFiles" />
    </Copy>

    <Message Text="  Copied library sources: @(_CopiedLibraryFiles->'%(Filename)%(Extension)', ', ')"
             Importance="normal"
             Condition="'@(_CopiedLibraryFiles)' != ''" />
    <Message Text="========================================" Importance="high" />
  </Target>

  <!-- ============================================================
       Android Manifest Resolution

       Resolves AndroidManifest items into the AndroidManifestFile
       property and recomposes GradleProperties so the Build target
       picks up the resolved value.
       ============================================================ -->

  <Target Name="_ResolveAndroidManifest"
          BeforeTargets="Build;Rebuild;Clean;StageJavaSources">

    <!-- Validate at most one AndroidManifest item exists -->
    <Error Text="Multiple AndroidManifest items found: @(AndroidManifest). Only one manifest file is supported."
           Condition="'@(AndroidManifest->Count())' != '0' AND '@(AndroidManifest->Count())' != '1'" />

    <!-- If an AndroidManifest item exists, use it as the manifest file -->
    <PropertyGroup Condition="'@(AndroidManifest)' != ''">
      <AndroidManifestFile>@(AndroidManifest->'%(FullPath)')</AndroidManifestFile>
    </PropertyGroup>

    <!-- Re-compose GradleProperties with the resolved manifest path.
         GradleProperties was evaluated statically at project load with the default
         AndroidManifestFile value. We must redefine it here so the Build/Rebuild/Clean
         targets pick up the resolved value. -->
    <PropertyGroup>
      <ProjectGradleProperties>-PjniLibsDir="$(JniLibsStagingDir)" -PandroidManifest="$(AndroidManifestFile)" -PandroidPackageName="$(AndroidPackageName)" -PandroidMinSdk=$(AndroidMinSdkVersion) -PandroidTargetSdk=$(AndroidTargetSdkVersion) -PgradleDependencies="$(GradleDependencies)"</ProjectGradleProperties>
      <GradleProperties>$(GradleBaseProperties) $(ProjectGradleProperties)</GradleProperties>
    </PropertyGroup>

    <Message Text="Using Android manifest: $(AndroidManifestFile)" Importance="high" />

    <Error Text="Android manifest file not found: $(AndroidManifestFile). Ensure the file exists or update the AndroidManifest item."
           Condition="!Exists('$(AndroidManifestFile)')" />
  </Target>

  <!-- ============================================================
       Deploy Target

       Installs the built APK to a connected device via ADB.
       ============================================================ -->

  <Target Name="Deploy" DependsOnTargets="Build">
    <Message Text="Deploying to device..." Importance="high" />
    <PropertyGroup>
      <ApkFile Condition="$(Configuration.Contains('Release'))">$(ApkOutputPath)\release\app-release.apk</ApkFile>
      <ApkFile Condition="'$(ApkFile)' == ''">$(ApkOutputPath)\debug\app-debug.apk</ApkFile>
    </PropertyGroup>

    <Exec Command="&quot;$(AndroidSdkPath)\platform-tools\adb.exe&quot; install -r &quot;$(ApkFile)&quot;"
          ConsoleToMsBuild="true"
          Condition="Exists('$(ApkFile)')" />

    <Error Text="APK not found at $(ApkFile). Build the project first."
           Condition="!Exists('$(ApkFile)')" />
  </Target>

</Project>
